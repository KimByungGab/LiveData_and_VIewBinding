라이브데이터와 뷰바인딩 예제를 통한 구조 코딩

MVVM 구조 중 뷰모델까지의 구조를 코딩해보았다.

뷰(액티비티, 프래그먼트 등 화면. 레이아웃 xml을 뷰 바인딩을 통해 접근.) -> 뷰모델(화면에 나올 데이터를 유지 및 보관하는 클래스. LiveData를 이용해서 변수가 달라지면 자동으로 뷰도 변경.) <-> 모델(뷰모델과 상호작용하기 위한 클래스. 보통 데이터를 가져올 때 여기서 한다. SQLite를 적용해서 내부 데이터를 가져오든 Retrofit과 같은 통신을 이용해서 외부 데이터를 가져오는 것을 여기서 한다.)

기존에 MVP 모델을 즐겨 사용했는데 이번에 AAC를 공부하고 웹에서 React와 Vue.js를 공부하면서 생각해봤는데 전체적으로 MVVM처럼 화면에서 기능동작 리스너를 작동시키면 뷰모델이 기능을 받아 리포지터리와 같은 모델에서 기능처리를 진행하고 기능에 대한 데이터를 받아 뷰모델의 데이터에 넣으면 뷰모델의 데이터와 연동되어서 뷰가 알아서 바뀐다는 점이 너무나도 똑같다. 전체적으로 프론트에서는 무서울정도로 똑같았다. 신기하네. 생각하는 게 다 똑같은건가.

여러 Jetpack을 사용하면서 새로운 뷰바인딩도 편했다. 기존에 코틀린익스텐션을 사용한 것도 좋았던 것은 사실이지만 이쪽도 사용법을 보니까 카멜표기법으로 바뀌는것도 개인적으로는 좋다. 코틀린익스텐션에서 사용하면서 각각의 id가 겹칠 수 있었는데 좀 더 세분화되서 좋았다. '누구누구바인딩.어느아이디' 로 받을 수 있어서 좀 더 전역 스페이스가 오염되지 않는 것 같다. 무엇보다 기존에 Java를 사용하면서 findViewById로 여러개를 입력하는 것도 정말 싫었는데 뷰바인딩은 나쁘지 않았다. 누구누구바인딩.어느아이디 로 쓰는 게 살짝 좀 더 많아져서 귀찮기는 한데....

첨언으로 데이터바인딩을 안 쓴 이유는 찾아보니까 데이터바인딩이 뷰바인딩에 xml 내에서 코틀린 코드를 넣는 것을 보았다. 극히 개인적이지만 나는 정말 마음에 들지 않았다. 구조는 구조에만, 기능은 기능에만 딱 집중하고 싶은데 얘는 오지랖 떠는 것 같다. 이런 건 싫어서 뷰바인딩을 택했다.

전체적으로 매우 만족스럽다. 다음부터 코딩할 때 이런 방식으로 진행해야겠다.

다음에는 Room을 사용해봐야겠다. 사실 지금도 SQLite를 쌩으로 이용하는데 전혀 귀찮다고 생각들지는 않는데 궁금하긴 하다. JetPack에 조은 거 많네~!
